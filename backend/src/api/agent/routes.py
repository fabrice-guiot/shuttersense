"""
Agent API routes for distributed agent architecture.

This module defines REST endpoints for agent operations:
- Registration (using one-time tokens)
- Heartbeat updates
- Job claiming and execution (Phase 3)
- Progress reporting (Phase 3)

API version: v1
Base path: /api/agent/v1
"""

import asyncio
from datetime import datetime
from typing import List

from fastapi import APIRouter, Depends, HTTPException, WebSocket, WebSocketDisconnect, status
from sqlalchemy.orm import Session

from backend.src.utils.websocket import get_connection_manager

from backend.src.db.database import get_db
from backend.src.middleware.tenant import TenantContext, get_tenant_context
from backend.src.services.agent_service import AgentService
from backend.src.services.exceptions import NotFoundError, ValidationError as ServiceValidationError
from backend.src.api.agent.schemas import (
    # Registration
    AgentRegistrationRequest,
    AgentRegistrationResponse,
    RegistrationTokenCreateRequest,
    RegistrationTokenResponse,
    RegistrationTokenListItem,
    RegistrationTokenListResponse,
    # Heartbeat
    HeartbeatRequest,
    HeartbeatResponse,
    # Agent management
    AgentResponse,
    AgentListResponse,
    AgentPoolStatusResponse,
    AgentUpdateRequest,
)
from backend.src.api.agent.dependencies import AgentContext, get_agent_context


# Create router with prefix and tags
router = APIRouter(prefix="/api/agent/v1", tags=["agents"])


# ============================================================================
# Helper Functions
# ============================================================================

def get_agent_service(db: Session = Depends(get_db)) -> AgentService:
    """Dependency to get AgentService."""
    return AgentService(db)


def agent_to_response(agent, current_job_guid: str = None) -> AgentResponse:
    """Convert Agent model to response schema."""
    return AgentResponse(
        guid=agent.guid,
        name=agent.name,
        hostname=agent.hostname,
        os_info=agent.os_info,
        status=agent.status,
        error_message=agent.error_message,
        last_heartbeat=agent.last_heartbeat,
        capabilities=agent.capabilities,
        version=agent.version,
        created_at=agent.created_at,
        team_guid=agent.team.guid if agent.team else "",
        current_job_guid=current_job_guid,
    )


# ============================================================================
# Public Endpoints (No Auth Required)
# ============================================================================

@router.post(
    "/register",
    response_model=AgentRegistrationResponse,
    status_code=status.HTTP_201_CREATED,
    summary="Register a new agent",
    description="Register a new agent using a one-time registration token. "
                "The API key is only returned once - store it securely."
)
async def register_agent(
    data: AgentRegistrationRequest,
    service: AgentService = Depends(get_agent_service),
):
    """
    Register a new agent using a one-time registration token.

    This endpoint is public (no auth required) because the agent doesn't
    have credentials yet - it's obtaining them through registration.

    The registration token was generated by an admin through the web UI.
    """
    try:
        result = service.register_agent(
            plaintext_token=data.registration_token,
            name=data.name,
            hostname=data.hostname,
            os_info=data.os_info,
            capabilities=data.capabilities,
            version=data.version,
            binary_checksum=data.binary_checksum,
        )

        # Broadcast pool status update after registration
        if result.agent.team_id:
            pool_status = service.get_pool_status(result.agent.team_id)
            manager = get_connection_manager()
            asyncio.create_task(
                manager.broadcast_agent_pool_status(result.agent.team_id, pool_status)
            )

        return AgentRegistrationResponse(
            guid=result.agent.guid,
            api_key=result.api_key,
            name=result.agent.name,
            team_guid=result.agent.team.guid if result.agent.team else "",
        )

    except ServiceValidationError as e:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=str(e)
        )
    except NotFoundError as e:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=str(e)
        )


# ============================================================================
# Agent-Authenticated Endpoints
# ============================================================================

@router.post(
    "/heartbeat",
    response_model=HeartbeatResponse,
    summary="Send agent heartbeat",
    description="Send periodic heartbeat to maintain online status. "
                "Agents should send heartbeat every 30 seconds."
)
async def send_heartbeat(
    data: HeartbeatRequest,
    ctx: AgentContext = Depends(get_agent_context),
    service: AgentService = Depends(get_agent_service),
):
    """
    Process agent heartbeat.

    Updates agent status, last_heartbeat timestamp, and optionally
    capabilities/version if changed. Also updates job progress if provided.
    """
    # Get agent from database
    agent = service.get_agent_by_guid(ctx.agent_guid, ctx.team_id)
    if not agent:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Agent not found"
        )

    # Process heartbeat
    # Note: current_job_guid and progress are handled via job service (Phase 3)
    service.process_heartbeat(
        agent=agent,
        status=data.status,
        capabilities=data.capabilities,
        version=data.version,
        error_message=data.error_message,
    )

    # Broadcast pool status update to connected clients (T059)
    pool_status = service.get_pool_status(ctx.team_id)
    manager = get_connection_manager()
    asyncio.create_task(
        manager.broadcast_agent_pool_status(ctx.team_id, pool_status)
    )

    return HeartbeatResponse(
        acknowledged=True,
        server_time=datetime.utcnow(),
        pending_commands=[],  # TODO: Implement command queue in Phase 4
    )


@router.get(
    "/me",
    response_model=AgentResponse,
    summary="Get current agent info",
    description="Get information about the currently authenticated agent."
)
async def get_current_agent(
    ctx: AgentContext = Depends(get_agent_context),
    service: AgentService = Depends(get_agent_service),
):
    """Get information about the currently authenticated agent."""
    agent = service.get_agent_by_guid(ctx.agent_guid, ctx.team_id)
    if not agent:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Agent not found"
        )

    # TODO: Get current job GUID if any (Phase 3)
    return agent_to_response(agent)


# ============================================================================
# Admin Endpoints (User Auth Required)
# ============================================================================

@router.post(
    "/tokens",
    response_model=RegistrationTokenResponse,
    status_code=status.HTTP_201_CREATED,
    summary="Create registration token",
    description="Create a one-time registration token for agent setup. "
                "Requires user authentication (session or API token)."
)
async def create_registration_token(
    data: RegistrationTokenCreateRequest,
    ctx: TenantContext = Depends(get_tenant_context),
    service: AgentService = Depends(get_agent_service),
    db: Session = Depends(get_db),
):
    """
    Create a one-time registration token.

    This endpoint is protected by user authentication (not agent auth).
    Only authenticated users can create registration tokens.
    """
    result = service.create_registration_token(
        team_id=ctx.team_id,
        created_by_user_id=ctx.user_id,
        name=data.name,
        expiration_hours=data.expires_in_hours,
    )

    # Get creator email for response
    from backend.src.models import User
    creator = db.query(User).filter(User.id == ctx.user_id).first()
    creator_email = creator.email if creator else None

    return RegistrationTokenResponse(
        guid=result.token.guid,
        token=result.plaintext_token,
        name=result.token.name,
        expires_at=result.token.expires_at,
        is_valid=result.token.is_valid,
        created_at=result.token.created_at,
        created_by_email=creator_email,
    )


@router.get(
    "/tokens",
    response_model=RegistrationTokenListResponse,
    summary="List registration tokens",
    description="List all registration tokens for the current team."
)
async def list_registration_tokens(
    ctx: TenantContext = Depends(get_tenant_context),
    db: Session = Depends(get_db),
    include_used: bool = False,
):
    """List registration tokens for the current team."""
    from backend.src.models.agent_registration_token import AgentRegistrationToken
    from backend.src.models import User
    from backend.src.models.agent import Agent

    query = db.query(AgentRegistrationToken).filter(
        AgentRegistrationToken.team_id == ctx.team_id
    )

    if not include_used:
        query = query.filter(AgentRegistrationToken.is_used == False)

    tokens = query.order_by(AgentRegistrationToken.created_at.desc()).all()

    items = []
    for token in tokens:
        creator = db.query(User).filter(User.id == token.created_by_user_id).first()
        # Get agent GUID if used
        agent_guid = None
        if token.used_by_agent_id:
            agent = db.query(Agent).filter(Agent.id == token.used_by_agent_id).first()
            agent_guid = agent.guid if agent else None

        items.append(RegistrationTokenListItem(
            guid=token.guid,
            name=token.name,
            expires_at=token.expires_at,
            is_valid=token.is_valid,
            is_used=token.is_used,
            used_by_agent_guid=agent_guid,
            created_at=token.created_at,
            created_by_email=creator.email if creator else None,
        ))

    return RegistrationTokenListResponse(
        tokens=items,
        total_count=len(items),
    )


@router.delete(
    "/tokens/{guid}",
    status_code=status.HTTP_204_NO_CONTENT,
    summary="Delete registration token",
    description="Delete an unused registration token."
)
async def delete_registration_token(
    guid: str,
    ctx: TenantContext = Depends(get_tenant_context),
    db: Session = Depends(get_db),
):
    """Delete an unused registration token."""
    from backend.src.models.agent_registration_token import AgentRegistrationToken

    # Parse GUID to get UUID for database query
    try:
        token_uuid = AgentRegistrationToken.parse_guid(guid)
    except ValueError:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Registration token not found"
        )

    token = db.query(AgentRegistrationToken).filter(
        AgentRegistrationToken.uuid == token_uuid,
        AgentRegistrationToken.team_id == ctx.team_id,
    ).first()

    if not token:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Registration token not found"
        )

    if token.is_used:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Cannot delete a used registration token"
        )

    db.delete(token)
    db.commit()
    return None


@router.get(
    "",
    response_model=AgentListResponse,
    summary="List agents",
    description="List all agents for the current team."
)
async def list_agents(
    ctx: TenantContext = Depends(get_tenant_context),
    service: AgentService = Depends(get_agent_service),
    include_revoked: bool = False,
):
    """List all agents for the current team."""
    agents = service.list_agents(
        team_id=ctx.team_id,
        include_revoked=include_revoked,
    )

    return AgentListResponse(
        agents=[agent_to_response(a) for a in agents],
        total_count=len(agents),
    )


@router.get(
    "/pool-status",
    response_model=AgentPoolStatusResponse,
    summary="Get agent pool status",
    description="Get aggregate status for the agent pool (for header badge)."
)
async def get_pool_status(
    ctx: TenantContext = Depends(get_tenant_context),
    service: AgentService = Depends(get_agent_service),
):
    """Get agent pool status for header badge."""
    status_data = service.get_pool_status(ctx.team_id)

    return AgentPoolStatusResponse(
        online_count=status_data["online_count"],
        offline_count=status_data["offline_count"],
        idle_count=status_data["idle_count"],
        running_jobs_count=status_data["running_jobs_count"],
        status=status_data["status"],
    )


@router.websocket("/ws/pool-status")
async def pool_status_websocket(
    websocket: WebSocket,
    db: Session = Depends(get_db),
):
    """
    WebSocket endpoint for real-time agent pool status updates.

    Clients subscribe to receive pool status updates when agents come
    online/offline, start/complete jobs, etc.

    Authentication: Session-based (same as HTTP endpoints).
    The team is derived from the authenticated user's session.

    Issue #90 - Distributed Agent Architecture (Phase 4)
    Task: T057
    """
    from backend.src.middleware.tenant import get_websocket_tenant_context

    # Must accept the WebSocket connection BEFORE any validation
    # Otherwise close() fails with 403 since connection isn't established
    await websocket.accept()

    # Authenticate using session (same as HTTP endpoints)
    ctx = await get_websocket_tenant_context(websocket, db)
    if not ctx:
        await websocket.close(code=4001, reason="Authentication required")
        return

    team_id = ctx.team_id
    manager = get_connection_manager()
    channel = manager.get_agent_pool_channel(team_id)

    # Register this already-accepted connection to the channel
    await manager.register_accepted(channel, websocket)

    try:
        # Send initial pool status
        service = AgentService(db)
        initial_status = service.get_pool_status(team_id)
        await websocket.send_json({
            "type": "agent_pool_status",
            "pool_status": initial_status
        })

        # Keep connection alive and handle pings
        while True:
            try:
                data = await asyncio.wait_for(
                    websocket.receive_text(),
                    timeout=30.0
                )
                if data == "ping":
                    await websocket.send_text("pong")
            except asyncio.TimeoutError:
                # Send heartbeat to keep connection alive
                try:
                    await websocket.send_json({"type": "heartbeat"})
                except Exception:
                    break
    except WebSocketDisconnect:
        pass
    finally:
        manager.disconnect(channel, websocket)


@router.get(
    "/{guid}",
    response_model=AgentResponse,
    summary="Get agent by GUID",
    description="Get details of a specific agent."
)
async def get_agent(
    guid: str,
    ctx: TenantContext = Depends(get_tenant_context),
    service: AgentService = Depends(get_agent_service),
):
    """Get details of a specific agent."""
    try:
        agent = service.get_agent_by_guid(guid, ctx.team_id)
    except (ValueError, NotFoundError):
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Agent not found"
        )
    if not agent:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Agent not found"
        )

    return agent_to_response(agent)


@router.patch(
    "/{guid}",
    response_model=AgentResponse,
    summary="Update agent",
    description="Update agent name."
)
async def update_agent(
    guid: str,
    data: AgentUpdateRequest,
    ctx: TenantContext = Depends(get_tenant_context),
    service: AgentService = Depends(get_agent_service),
):
    """Update agent name."""
    try:
        agent = service.get_agent_by_guid(guid, ctx.team_id)
    except (ValueError, NotFoundError):
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Agent not found"
        )
    if not agent:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Agent not found"
        )

    agent = service.rename_agent(agent, data.name)
    return agent_to_response(agent)


@router.delete(
    "/{guid}",
    status_code=status.HTTP_204_NO_CONTENT,
    summary="Revoke agent",
    description="Revoke an agent's access. The agent will no longer be able to connect."
)
async def revoke_agent(
    guid: str,
    reason: str = "Revoked by administrator",
    ctx: TenantContext = Depends(get_tenant_context),
    service: AgentService = Depends(get_agent_service),
):
    """Revoke an agent's access."""
    try:
        agent = service.get_agent_by_guid(guid, ctx.team_id)
    except (ValueError, NotFoundError):
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Agent not found"
        )
    if not agent:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Agent not found"
        )

    service.revoke_agent(agent, reason)

    # Broadcast pool status update after revocation
    pool_status = service.get_pool_status(ctx.team_id)
    manager = get_connection_manager()
    asyncio.create_task(
        manager.broadcast_agent_pool_status(ctx.team_id, pool_status)
    )

    return None
