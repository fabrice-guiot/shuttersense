"""
Agent API routes for distributed agent architecture.

This module defines REST endpoints for agent operations:
- Registration (using one-time tokens)
- Heartbeat updates
- Job claiming and execution (Phase 3)
- Progress reporting (Phase 3)

API version: v1
Base path: /api/agent/v1
"""

import asyncio
from datetime import datetime
from typing import List

from fastapi import APIRouter, Depends, HTTPException, Response, WebSocket, WebSocketDisconnect, status
from sqlalchemy.orm import Session

from backend.src.utils.websocket import get_connection_manager
from backend.src.services.tool_service import _db_job_to_response

from backend.src.db.database import get_db
from backend.src.middleware.tenant import TenantContext, get_tenant_context
from backend.src.services.agent_service import AgentService
from backend.src.services.connector_service import ConnectorService
from backend.src.api.connectors import get_connector_service
from backend.src.services.exceptions import NotFoundError, ValidationError as ServiceValidationError
from backend.src.models.connector import CredentialLocation
from backend.src.api.agent.schemas import (
    # Registration
    AgentRegistrationRequest,
    AgentRegistrationResponse,
    RegistrationTokenCreateRequest,
    RegistrationTokenResponse,
    RegistrationTokenListItem,
    RegistrationTokenListResponse,
    # Heartbeat
    HeartbeatRequest,
    HeartbeatResponse,
    # Agent management
    AgentResponse,
    AgentListResponse,
    AgentPoolStatusResponse,
    AgentUpdateRequest,
    # Job schemas (Phase 5)
    JobClaimResponse,
    JobProgressRequest,
    JobCompleteRequest,
    JobFailRequest,
    JobStatusResponse,
    JobConfigData,
    JobConfigResponse,
    PipelineData,
    ConnectorTestData,
    # Connector schemas (Phase 8)
    AgentConnectorResponse,
    AgentConnectorListResponse,
    AgentConnectorMetadataResponse,
    ReportConnectorCapabilityRequest,
    ReportConnectorCapabilityResponse,
)
from backend.src.api.agent.dependencies import AgentContext, get_agent_context, require_online_agent


# Create router with prefix and tags
router = APIRouter(prefix="/api/agent/v1", tags=["agents"])


# ============================================================================
# Helper Functions
# ============================================================================

def get_agent_service(db: Session = Depends(get_db)) -> AgentService:
    """Dependency to get AgentService."""
    return AgentService(db)


def agent_to_response(agent, current_job_guid: str = None) -> AgentResponse:
    """Convert Agent model to response schema."""
    return AgentResponse(
        guid=agent.guid,
        name=agent.name,
        hostname=agent.hostname,
        os_info=agent.os_info,
        status=agent.status,
        error_message=agent.error_message,
        last_heartbeat=agent.last_heartbeat,
        capabilities=agent.capabilities,
        authorized_roots=agent.authorized_roots,
        version=agent.version,
        created_at=agent.created_at,
        team_guid=agent.team.guid if agent.team else "",
        current_job_guid=current_job_guid,
    )


# ============================================================================
# Public Endpoints (No Auth Required)
# ============================================================================

@router.post(
    "/register",
    response_model=AgentRegistrationResponse,
    status_code=status.HTTP_201_CREATED,
    summary="Register a new agent",
    description="Register a new agent using a one-time registration token. "
                "The API key is only returned once - store it securely."
)
async def register_agent(
    data: AgentRegistrationRequest,
    service: AgentService = Depends(get_agent_service),
):
    """
    Register a new agent using a one-time registration token.

    This endpoint is public (no auth required) because the agent doesn't
    have credentials yet - it's obtaining them through registration.

    The registration token was generated by an admin through the web UI.
    """
    import logging
    logger = logging.getLogger("agent")

    try:
        result = service.register_agent(
            plaintext_token=data.registration_token,
            name=data.name,
            hostname=data.hostname,
            os_info=data.os_info,
            capabilities=data.capabilities,
            authorized_roots=data.authorized_roots,
            version=data.version,
            binary_checksum=data.binary_checksum,
        )

        # Broadcast pool status update after registration
        if result.agent.team_id:
            pool_status = service.get_pool_status(result.agent.team_id)
            manager = get_connection_manager()
            asyncio.create_task(
                manager.broadcast_agent_pool_status(result.agent.team_id, pool_status)
            )

        return AgentRegistrationResponse(
            guid=result.agent.guid,
            api_key=result.api_key,
            name=result.agent.name,
            team_guid=result.agent.team.guid if result.agent.team else "",
            authorized_roots=result.agent.authorized_roots,
        )

    except ServiceValidationError as e:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=str(e)
        )
    except NotFoundError as e:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=str(e)
        )
    except Exception as e:
        logger.exception(f"Unexpected error during agent registration: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Registration failed: {str(e)}"
        )


# ============================================================================
# Agent-Authenticated Endpoints
# ============================================================================

@router.post(
    "/heartbeat",
    response_model=HeartbeatResponse,
    summary="Send agent heartbeat",
    description="Send periodic heartbeat to maintain online status. "
                "Agents should send heartbeat every 30 seconds."
)
async def send_heartbeat(
    data: HeartbeatRequest,
    ctx: AgentContext = Depends(get_agent_context),
    service: AgentService = Depends(get_agent_service),
):
    """
    Process agent heartbeat.

    Updates agent status, last_heartbeat timestamp, and optionally
    capabilities/version if changed. Also updates job progress if provided.
    """
    # Get agent from database
    agent = service.get_agent_by_guid(ctx.agent_guid, ctx.team_id)
    if not agent:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Agent not found"
        )

    # Process heartbeat
    # Note: current_job_guid and progress are handled via job service (Phase 3)
    service.process_heartbeat(
        agent=agent,
        status=data.status,
        capabilities=data.capabilities,
        authorized_roots=data.authorized_roots,
        version=data.version,
        error_message=data.error_message,
    )

    # Get pending commands for this agent
    pending_commands = service.get_and_clear_commands(ctx.agent_id)

    # Broadcast pool status update to connected clients (T059)
    pool_status = service.get_pool_status(ctx.team_id)
    manager = get_connection_manager()
    asyncio.create_task(
        manager.broadcast_agent_pool_status(ctx.team_id, pool_status)
    )

    return HeartbeatResponse(
        acknowledged=True,
        server_time=datetime.utcnow(),
        pending_commands=pending_commands,
    )


@router.get(
    "/me",
    response_model=AgentResponse,
    summary="Get current agent info",
    description="Get information about the currently authenticated agent."
)
async def get_current_agent(
    ctx: AgentContext = Depends(get_agent_context),
    service: AgentService = Depends(get_agent_service),
):
    """Get information about the currently authenticated agent."""
    agent = service.get_agent_by_guid(ctx.agent_guid, ctx.team_id)
    if not agent:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Agent not found"
        )

    # TODO: Get current job GUID if any (Phase 3)
    return agent_to_response(agent)


@router.post(
    "/disconnect",
    status_code=status.HTTP_204_NO_CONTENT,
    summary="Disconnect agent",
    description="Gracefully disconnect the agent and mark it as offline. "
                "Called by the agent during shutdown."
)
async def disconnect_agent(
    ctx: AgentContext = Depends(get_agent_context),
    service: AgentService = Depends(get_agent_service),
):
    """
    Gracefully disconnect the agent.

    Called by the agent when it's shutting down. This immediately marks
    the agent as OFFLINE and releases any assigned jobs.
    """
    agent = service.get_agent_by_guid(ctx.agent_guid, ctx.team_id)
    if not agent:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Agent not found"
        )

    service.disconnect_agent(agent)

    # Broadcast pool status update after disconnect
    pool_status = service.get_pool_status(ctx.team_id)
    manager = get_connection_manager()
    asyncio.create_task(
        manager.broadcast_agent_pool_status(ctx.team_id, pool_status)
    )

    return None


# ============================================================================
# Job Endpoints (Agent Auth Required - Phase 5)
# ============================================================================

@router.post(
    "/jobs/claim",
    response_model=JobClaimResponse,
    responses={204: {"description": "No jobs available"}},
    summary="Claim next available job",
    description="Claim the next available job for execution. Returns 204 if no jobs available."
)
async def claim_job(
    ctx: AgentContext = Depends(require_online_agent),
    service: AgentService = Depends(get_agent_service),
    db: Session = Depends(get_db),
):
    """
    Claim the next available job for the agent.

    Uses FOR UPDATE SKIP LOCKED for atomic claiming. Requires the agent
    to be in ONLINE status.

    Returns 204 No Content if no jobs are available.
    """
    from backend.src.services.job_coordinator_service import JobCoordinatorService

    coordinator = JobCoordinatorService(db)

    # Get agent to retrieve capabilities
    agent = service.get_agent_by_guid(ctx.agent_guid, ctx.team_id)
    if not agent:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Agent not found"
        )

    # Try to claim a job
    result = coordinator.claim_job(
        agent_id=ctx.agent_id,
        team_id=ctx.team_id,
        agent_capabilities=agent.capabilities,
    )

    if not result:
        # No jobs available - return 204
        return Response(status_code=status.HTTP_204_NO_CONTENT)

    job = result.job

    # Build response with collection path if applicable
    collection_guid = None
    collection_path = None
    if job.collection:
        collection_guid = job.collection.guid
        collection_path = job.collection.location

    pipeline_guid = None
    if job.pipeline:
        pipeline_guid = job.pipeline.guid

    # Broadcast updates
    manager = get_connection_manager()

    # Broadcast pool status update (job assigned = running)
    pool_status = service.get_pool_status(ctx.team_id)
    asyncio.create_task(
        manager.broadcast_agent_pool_status(ctx.team_id, pool_status)
    )

    # Broadcast job update so frontend shows the job as running
    job_response = _db_job_to_response(job)
    asyncio.create_task(
        manager.broadcast_global_job_update(job_response.model_dump(mode="json"))
    )

    return JobClaimResponse(
        guid=job.guid,
        tool=job.tool,
        mode=job.mode,
        collection_guid=collection_guid,
        collection_path=collection_path,
        pipeline_guid=pipeline_guid,
        parameters=job.parameters,
        signing_secret=result.signing_secret,
        priority=job.priority,
        retry_count=job.retry_count,
        max_retries=job.max_retries,
    )


@router.post(
    "/jobs/{job_guid}/progress",
    response_model=JobStatusResponse,
    summary="Update job progress",
    description="Update progress for a running job."
)
async def update_job_progress(
    job_guid: str,
    data: JobProgressRequest,
    ctx: AgentContext = Depends(require_online_agent),
    service: AgentService = Depends(get_agent_service),
    db: Session = Depends(get_db),
):
    """
    Update progress for a running job.

    The job must be assigned to this agent. Progress updates are
    broadcast to connected WebSocket clients.
    """
    from backend.src.services.job_coordinator_service import JobCoordinatorService

    coordinator = JobCoordinatorService(db)

    try:
        # Build progress dict
        progress = {
            "stage": data.stage,
            "percentage": data.percentage,
            "files_scanned": data.files_scanned,
            "total_files": data.total_files,
            "current_file": data.current_file,
            "message": data.message,
        }
        # Remove None values
        progress = {k: v for k, v in progress.items() if v is not None}

        job = coordinator.update_progress(
            job_guid=job_guid,
            agent_id=ctx.agent_id,
            team_id=ctx.team_id,
            progress=progress,
        )

        # Broadcast updates
        manager = get_connection_manager()

        # Broadcast job progress to WebSocket clients
        asyncio.create_task(
            manager.broadcast_job_progress(ctx.team_id, job.guid, progress)
        )

        # Also broadcast full job update (for status changes like ASSIGNED -> RUNNING)
        job_response = _db_job_to_response(job)
        asyncio.create_task(
            manager.broadcast_global_job_update(job_response.model_dump(mode="json"))
        )

        return JobStatusResponse(
            guid=job.guid,
            status=job.status.value,
            tool=job.tool,
            progress=job.progress,
            error_message=job.error_message,
        )

    except NotFoundError as e:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=str(e)
        )
    except ServiceValidationError as e:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=str(e)
        )


@router.post(
    "/jobs/{job_guid}/complete",
    response_model=JobStatusResponse,
    summary="Complete job with results",
    description="Mark a job as completed and submit results."
)
async def complete_job(
    job_guid: str,
    data: JobCompleteRequest,
    ctx: AgentContext = Depends(get_agent_context),
    service: AgentService = Depends(get_agent_service),
    db: Session = Depends(get_db),
):
    """
    Complete a job with results.

    Creates an AnalysisResult record and links it to the job.
    The signature must match the HMAC-SHA256 of the results using
    the signing secret provided during claim.
    """
    from backend.src.services.job_coordinator_service import (
        JobCoordinatorService,
        JobCompletionData,
    )

    coordinator = JobCoordinatorService(db)

    try:
        completion_data = JobCompletionData(
            results=data.results,
            report_html=data.report_html,
            files_scanned=data.files_scanned,
            issues_found=data.issues_found,
            signature=data.signature,
        )

        job = coordinator.complete_job(
            job_guid=job_guid,
            agent_id=ctx.agent_id,
            team_id=ctx.team_id,
            completion_data=completion_data,
        )

        # Refresh job to get result relationship
        db.refresh(job)

        # Broadcast updates
        manager = get_connection_manager()

        # Broadcast pool status update (job completed)
        pool_status = service.get_pool_status(ctx.team_id)
        asyncio.create_task(
            manager.broadcast_agent_pool_status(ctx.team_id, pool_status)
        )

        # Broadcast full job update so frontend updates the card
        job_response = _db_job_to_response(job)
        asyncio.create_task(
            manager.broadcast_global_job_update(job_response.model_dump(mode="json"))
        )

        return JobStatusResponse(
            guid=job.guid,
            status=job.status.value,
            tool=job.tool,
            progress=None,
            error_message=None,
        )

    except NotFoundError as e:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=str(e)
        )
    except ServiceValidationError as e:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=str(e)
        )


@router.post(
    "/jobs/{job_guid}/fail",
    response_model=JobStatusResponse,
    summary="Mark job as failed",
    description="Mark a job as failed with an error message."
)
async def fail_job(
    job_guid: str,
    data: JobFailRequest,
    ctx: AgentContext = Depends(get_agent_context),
    service: AgentService = Depends(get_agent_service),
    db: Session = Depends(get_db),
):
    """
    Mark a job as failed.

    The job must be assigned to this agent. Failed jobs may be
    retried if retry_count < max_retries.
    """
    from backend.src.services.job_coordinator_service import JobCoordinatorService

    coordinator = JobCoordinatorService(db)

    try:
        job = coordinator.fail_job(
            job_guid=job_guid,
            agent_id=ctx.agent_id,
            team_id=ctx.team_id,
            error_message=data.error_message,
            signature=data.signature,
        )

        # Refresh job to get result relationship
        db.refresh(job)

        # Broadcast updates
        manager = get_connection_manager()

        # Broadcast pool status update (job failed)
        pool_status = service.get_pool_status(ctx.team_id)
        asyncio.create_task(
            manager.broadcast_agent_pool_status(ctx.team_id, pool_status)
        )

        # Broadcast full job update so frontend updates the card
        job_response = _db_job_to_response(job)
        asyncio.create_task(
            manager.broadcast_global_job_update(job_response.model_dump(mode="json"))
        )

        return JobStatusResponse(
            guid=job.guid,
            status=job.status.value,
            tool=job.tool,
            progress=None,
            error_message=job.error_message,
        )

    except NotFoundError as e:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=str(e)
        )
    except ServiceValidationError as e:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=str(e)
        )


@router.get(
    "/jobs/{job_guid}/config",
    response_model=JobConfigResponse,
    summary="Get job-specific configuration",
    description="Get configuration needed for executing a specific job."
)
async def get_job_config(
    job_guid: str,
    ctx: AgentContext = Depends(get_agent_context),
    db: Session = Depends(get_db),
    connector_service: ConnectorService = Depends(get_connector_service),
):
    """
    Get configuration for a specific job.

    Returns the team configuration plus job-specific details like the
    collection path. The requesting agent must be assigned to the job.
    """
    from backend.src.models.job import Job
    from backend.src.services.config_loader import DatabaseConfigLoader

    # Parse job GUID
    try:
        job_uuid = Job.parse_guid(job_guid)
    except ValueError:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Job not found"
        )

    # Get job
    job = db.query(Job).filter(
        Job.uuid == job_uuid,
        Job.team_id == ctx.team_id,
    ).first()

    if not job:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Job not found"
        )

    # Verify agent is assigned to this job
    if job.agent_id != ctx.agent_id:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Job is not assigned to this agent"
        )

    # Get config from database
    loader = DatabaseConfigLoader(team_id=ctx.team_id, db=db)

    # Get collection path if applicable
    collection_path = None
    if job.collection:
        collection_path = job.collection.location

    # Get pipeline data if applicable
    pipeline_guid = None
    pipeline_data = None
    if job.pipeline:
        pipeline_guid = job.pipeline.guid
        pipeline_data = PipelineData(
            guid=job.pipeline.guid,
            name=job.pipeline.name,
            version=job.pipeline_version or job.pipeline.version,  # Use job's version or current
            nodes=job.pipeline.nodes_json or [],
            edges=job.pipeline.edges_json or [],
        )

    # Get connector data for ALL jobs with connectors (not just collection_test)
    # This allows agents to use storage adapters for remote collections
    connector_data = None
    if job.collection and job.collection.connector:
        connector = job.collection.connector

        # For SERVER credentials, decrypt and include credentials
        # For AGENT credentials, agent uses locally stored credentials
        credentials = None
        if connector.credential_location == CredentialLocation.SERVER:
            # Get connector with decrypted credentials
            connector_with_creds = connector_service.get_by_guid(
                connector.guid,
                team_id=ctx.team_id,
                decrypt_credentials=True
            )
            if connector_with_creds:
                credentials = getattr(connector_with_creds, 'decrypted_credentials', None)

        connector_data = ConnectorTestData(
            guid=connector.guid,
            type=connector.type.value,
            name=connector.name,
            credential_location=connector.credential_location.value,
            credentials=credentials,
        )

    return JobConfigResponse(
        job_guid=job.guid,
        config=JobConfigData(
            photo_extensions=loader.photo_extensions,
            metadata_extensions=loader.metadata_extensions,
            camera_mappings=loader.camera_mappings,
            processing_methods=loader.processing_methods,
            require_sidecar=loader.require_sidecar,
        ),
        collection_path=collection_path,
        pipeline_guid=pipeline_guid,
        pipeline=pipeline_data,
        connector=connector_data,
    )


# ============================================================================
# Admin Endpoints (User Auth Required)
# ============================================================================

@router.post(
    "/tokens",
    response_model=RegistrationTokenResponse,
    status_code=status.HTTP_201_CREATED,
    summary="Create registration token",
    description="Create a one-time registration token for agent setup. "
                "Requires user authentication (session or API token)."
)
async def create_registration_token(
    data: RegistrationTokenCreateRequest,
    ctx: TenantContext = Depends(get_tenant_context),
    service: AgentService = Depends(get_agent_service),
    db: Session = Depends(get_db),
):
    """
    Create a one-time registration token.

    This endpoint is protected by user authentication (not agent auth).
    Only authenticated users can create registration tokens.
    """
    result = service.create_registration_token(
        team_id=ctx.team_id,
        created_by_user_id=ctx.user_id,
        name=data.name,
        expiration_hours=data.expires_in_hours,
    )

    # Get creator email for response
    from backend.src.models import User
    creator = db.query(User).filter(User.id == ctx.user_id).first()
    creator_email = creator.email if creator else None

    return RegistrationTokenResponse(
        guid=result.token.guid,
        token=result.plaintext_token,
        name=result.token.name,
        expires_at=result.token.expires_at,
        is_valid=result.token.is_valid,
        created_at=result.token.created_at,
        created_by_email=creator_email,
    )


@router.get(
    "/tokens",
    response_model=RegistrationTokenListResponse,
    summary="List registration tokens",
    description="List all registration tokens for the current team."
)
async def list_registration_tokens(
    ctx: TenantContext = Depends(get_tenant_context),
    db: Session = Depends(get_db),
    include_used: bool = False,
):
    """List registration tokens for the current team."""
    from backend.src.models.agent_registration_token import AgentRegistrationToken
    from backend.src.models import User
    from backend.src.models.agent import Agent

    query = db.query(AgentRegistrationToken).filter(
        AgentRegistrationToken.team_id == ctx.team_id
    )

    if not include_used:
        query = query.filter(AgentRegistrationToken.is_used == False)

    tokens = query.order_by(AgentRegistrationToken.created_at.desc()).all()

    items = []
    for token in tokens:
        creator = db.query(User).filter(User.id == token.created_by_user_id).first()
        # Get agent GUID if used
        agent_guid = None
        if token.used_by_agent_id:
            agent = db.query(Agent).filter(Agent.id == token.used_by_agent_id).first()
            agent_guid = agent.guid if agent else None

        items.append(RegistrationTokenListItem(
            guid=token.guid,
            name=token.name,
            expires_at=token.expires_at,
            is_valid=token.is_valid,
            is_used=token.is_used,
            used_by_agent_guid=agent_guid,
            created_at=token.created_at,
            created_by_email=creator.email if creator else None,
        ))

    return RegistrationTokenListResponse(
        tokens=items,
        total_count=len(items),
    )


@router.delete(
    "/tokens/{guid}",
    status_code=status.HTTP_204_NO_CONTENT,
    summary="Delete registration token",
    description="Delete an unused registration token."
)
async def delete_registration_token(
    guid: str,
    ctx: TenantContext = Depends(get_tenant_context),
    db: Session = Depends(get_db),
):
    """Delete an unused registration token."""
    from backend.src.models.agent_registration_token import AgentRegistrationToken

    # Parse GUID to get UUID for database query
    try:
        token_uuid = AgentRegistrationToken.parse_guid(guid)
    except ValueError:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Registration token not found"
        )

    token = db.query(AgentRegistrationToken).filter(
        AgentRegistrationToken.uuid == token_uuid,
        AgentRegistrationToken.team_id == ctx.team_id,
    ).first()

    if not token:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Registration token not found"
        )

    if token.is_used:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Cannot delete a used registration token"
        )

    db.delete(token)
    db.commit()
    return None


@router.get(
    "",
    response_model=AgentListResponse,
    summary="List agents",
    description="List all agents for the current team."
)
async def list_agents(
    ctx: TenantContext = Depends(get_tenant_context),
    service: AgentService = Depends(get_agent_service),
    include_revoked: bool = False,
):
    """List all agents for the current team."""
    agents = service.list_agents(
        team_id=ctx.team_id,
        include_revoked=include_revoked,
    )

    return AgentListResponse(
        agents=[agent_to_response(a) for a in agents],
        total_count=len(agents),
    )


@router.get(
    "/pool-status",
    response_model=AgentPoolStatusResponse,
    summary="Get agent pool status",
    description="Get aggregate status for the agent pool (for header badge)."
)
async def get_pool_status(
    ctx: TenantContext = Depends(get_tenant_context),
    service: AgentService = Depends(get_agent_service),
):
    """Get agent pool status for header badge."""
    status_data = service.get_pool_status(ctx.team_id)

    return AgentPoolStatusResponse(
        online_count=status_data["online_count"],
        offline_count=status_data["offline_count"],
        idle_count=status_data["idle_count"],
        running_jobs_count=status_data["running_jobs_count"],
        status=status_data["status"],
    )


# ============================================================================
# Agent Connector Endpoints (Agent Auth Required - Phase 8)
# Must be defined BEFORE /{guid} to avoid route conflicts
# ============================================================================

# Credential field definitions for each connector type
CONNECTOR_CREDENTIAL_FIELDS = {
    "s3": [
        {"name": "aws_access_key_id", "type": "string", "required": True, "description": "AWS Access Key ID"},
        {"name": "aws_secret_access_key", "type": "password", "required": True, "description": "AWS Secret Access Key"},
        {"name": "region", "type": "string", "required": True, "description": "AWS Region (e.g., us-east-1)"},
        {"name": "bucket", "type": "string", "required": False, "description": "Default bucket (optional)"},
    ],
    "gcs": [
        {"name": "service_account_json", "type": "json", "required": True, "description": "Service Account JSON key file content"},
        {"name": "bucket", "type": "string", "required": False, "description": "Default bucket (optional)"},
    ],
    "smb": [
        {"name": "server", "type": "string", "required": True, "description": "Server address (hostname or IP)"},
        {"name": "share", "type": "string", "required": True, "description": "Share name"},
        {"name": "username", "type": "string", "required": True, "description": "Username"},
        {"name": "password", "type": "password", "required": True, "description": "Password"},
        {"name": "domain", "type": "string", "required": False, "description": "Domain (optional)"},
    ],
}


@router.get(
    "/connectors",
    response_model=AgentConnectorListResponse,
    summary="List connectors for credential configuration",
    description="List connectors that the agent can configure credentials for. "
                "Use pending_only=true to filter to only pending connectors."
)
async def list_connectors_for_agent(
    pending_only: bool = False,
    agent_ctx: AgentContext = Depends(require_online_agent),
    connector_service: ConnectorService = Depends(get_connector_service),
):
    import logging
    logging.getLogger("agent").info(f"list_connectors_for_agent called, agent={agent_ctx.agent_guid}")
    """
    List connectors available for agent credential configuration.

    Query Parameters:
        pending_only: If true, only return connectors with credential_location=pending

    Returns:
        List of connectors with their configuration status
    """
    # Get all connectors for the agent's team
    connectors = connector_service.list_connectors(team_id=agent_ctx.agent.team_id)

    # Filter based on credential_location
    # Agents can configure: pending (needs initial config) or agent (update/expand)
    # Agents cannot configure: server (credentials stored on server)
    filtered = []
    for conn in connectors:
        # Skip server-side credential connectors
        if conn.credential_location == CredentialLocation.SERVER:
            continue

        # If pending_only, only include pending connectors
        if pending_only and conn.credential_location != CredentialLocation.PENDING:
            continue

        # Check if this agent has credentials for this connector
        agent_capabilities = agent_ctx.agent.capabilities or []
        has_local = f"connector:{conn.guid}" in agent_capabilities

        filtered.append(AgentConnectorResponse(
            guid=conn.guid,
            name=conn.name,
            type=conn.type.value,
            credential_location=conn.credential_location.value,
            is_active=conn.is_active,
            created_at=conn.created_at,
            has_local_credentials=has_local,
        ))

    return AgentConnectorListResponse(connectors=filtered, total=len(filtered))


@router.get(
    "/connectors/{guid}/metadata",
    response_model=AgentConnectorMetadataResponse,
    summary="Get connector metadata for configuration",
    description="Get connector details and credential field definitions for configuration."
)
async def get_connector_metadata(
    guid: str,
    agent_ctx: AgentContext = Depends(require_online_agent),
    connector_service: ConnectorService = Depends(get_connector_service),
):
    """
    Get connector metadata needed for credential configuration.

    Path Parameters:
        guid: Connector GUID (con_xxx)

    Returns:
        Connector details and credential field definitions
    """
    # Get connector by GUID with team filtering
    connector = connector_service.get_by_guid(guid, team_id=agent_ctx.agent.team_id)

    if not connector:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Connector not found: {guid}"
        )

    # Cannot configure server-side credentials from agent
    if connector.credential_location == CredentialLocation.SERVER:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Cannot configure credentials for server-side connector from agent"
        )

    # Get credential field definitions for this connector type
    credential_fields = CONNECTOR_CREDENTIAL_FIELDS.get(connector.type.value, [])

    return AgentConnectorMetadataResponse(
        guid=connector.guid,
        name=connector.name,
        type=connector.type.value,
        credential_location=connector.credential_location.value,
        credential_fields=credential_fields,
    )


@router.post(
    "/connectors/{guid}/report-capability",
    response_model=ReportConnectorCapabilityResponse,
    summary="Report connector credential capability",
    description="Report that this agent has (or no longer has) credentials for a connector."
)
async def report_connector_capability(
    guid: str,
    request: ReportConnectorCapabilityRequest,
    agent_ctx: AgentContext = Depends(require_online_agent),
    agent_service: AgentService = Depends(get_agent_service),
    connector_service: ConnectorService = Depends(get_connector_service),
):
    """
    Report that this agent has credentials configured for a connector.

    Path Parameters:
        guid: Connector GUID (con_xxx)

    Request Body:
        has_credentials: Whether agent has valid credentials
        last_tested: When credentials were last successfully tested

    Returns:
        Acknowledgement and whether credential_location was updated

    Side Effects:
        - Updates agent capabilities to include/exclude connector:{guid}
        - If connector is pending and has_credentials=true, updates to agent
    """
    # Get connector by GUID with team filtering
    connector = connector_service.get_by_guid(guid, team_id=agent_ctx.agent.team_id)

    if not connector:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Connector not found: {guid}"
        )

    # Cannot configure server-side credentials from agent
    if connector.credential_location == CredentialLocation.SERVER:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Cannot report capability for server-side connector"
        )

    agent = agent_ctx.agent
    capabilities = list(agent.capabilities or [])
    capability_key = f"connector:{guid}"

    credential_location_updated = False

    if request.has_credentials:
        # Add capability if not present
        if capability_key not in capabilities:
            capabilities.append(capability_key)

        # If connector is pending, flip to agent (activation is user's decision in WebUI)
        if connector.credential_location == CredentialLocation.PENDING:
            connector_service.update_connector(
                connector_id=connector.id,
                credential_location=CredentialLocation.AGENT,
                update_credentials=False,  # Don't try to update server credentials
            )
            credential_location_updated = True
    else:
        # Remove capability if present
        if capability_key in capabilities:
            capabilities.remove(capability_key)

    # Update agent capabilities
    agent_service.update_capabilities(agent, capabilities)

    return ReportConnectorCapabilityResponse(
        acknowledged=True,
        credential_location_updated=credential_location_updated,
    )


@router.websocket("/ws/pool-status")
async def pool_status_websocket(
    websocket: WebSocket,
    db: Session = Depends(get_db),
):
    """
    WebSocket endpoint for real-time agent pool status updates.

    Clients subscribe to receive pool status updates when agents come
    online/offline, start/complete jobs, etc.

    Authentication: Session-based (same as HTTP endpoints).
    The team is derived from the authenticated user's session.

    Issue #90 - Distributed Agent Architecture (Phase 4)
    Task: T057
    """
    from backend.src.middleware.tenant import get_websocket_tenant_context

    # Must accept the WebSocket connection BEFORE any validation
    # Otherwise close() fails with 403 since connection isn't established
    await websocket.accept()

    # Authenticate using session (same as HTTP endpoints)
    ctx = await get_websocket_tenant_context(websocket, db)
    if not ctx:
        await websocket.close(code=4001, reason="Authentication required")
        return

    team_id = ctx.team_id
    manager = get_connection_manager()
    channel = manager.get_agent_pool_channel(team_id)

    # Register this already-accepted connection to the channel
    await manager.register_accepted(channel, websocket)

    try:
        # Send initial pool status
        service = AgentService(db)
        initial_status = service.get_pool_status(team_id)
        await websocket.send_json({
            "type": "agent_pool_status",
            "pool_status": initial_status
        })

        # Keep connection alive and handle pings
        while True:
            try:
                data = await asyncio.wait_for(
                    websocket.receive_text(),
                    timeout=30.0
                )
                if data == "ping":
                    await websocket.send_text("pong")
            except asyncio.TimeoutError:
                # Send heartbeat to keep connection alive
                try:
                    await websocket.send_json({"type": "heartbeat"})
                except Exception:
                    break
    except WebSocketDisconnect:
        pass
    finally:
        manager.disconnect(channel, websocket)


@router.get(
    "/{guid}",
    response_model=AgentResponse,
    summary="Get agent by GUID",
    description="Get details of a specific agent."
)
async def get_agent(
    guid: str,
    ctx: TenantContext = Depends(get_tenant_context),
    service: AgentService = Depends(get_agent_service),
):
    """Get details of a specific agent."""
    try:
        agent = service.get_agent_by_guid(guid, ctx.team_id)
    except (ValueError, NotFoundError):
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Agent not found"
        )
    if not agent:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Agent not found"
        )

    return agent_to_response(agent)


@router.patch(
    "/{guid}",
    response_model=AgentResponse,
    summary="Update agent",
    description="Update agent name."
)
async def update_agent(
    guid: str,
    data: AgentUpdateRequest,
    ctx: TenantContext = Depends(get_tenant_context),
    service: AgentService = Depends(get_agent_service),
):
    """Update agent name."""
    try:
        agent = service.get_agent_by_guid(guid, ctx.team_id)
    except (ValueError, NotFoundError):
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Agent not found"
        )
    if not agent:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Agent not found"
        )

    agent = service.rename_agent(agent, data.name)
    return agent_to_response(agent)


@router.delete(
    "/{guid}",
    status_code=status.HTTP_204_NO_CONTENT,
    summary="Revoke agent",
    description="Revoke an agent's access. The agent will no longer be able to connect."
)
async def revoke_agent(
    guid: str,
    reason: str = "Revoked by administrator",
    ctx: TenantContext = Depends(get_tenant_context),
    service: AgentService = Depends(get_agent_service),
):
    """Revoke an agent's access."""
    try:
        agent = service.get_agent_by_guid(guid, ctx.team_id)
    except (ValueError, NotFoundError):
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Agent not found"
        )
    if not agent:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Agent not found"
        )

    service.revoke_agent(agent, reason)

    # Broadcast pool status update after revocation
    pool_status = service.get_pool_status(ctx.team_id)
    manager = get_connection_manager()
    asyncio.create_task(
        manager.broadcast_agent_pool_status(ctx.team_id, pool_status)
    )

    return None
