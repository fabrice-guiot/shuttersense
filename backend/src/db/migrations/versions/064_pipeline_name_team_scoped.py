"""Change pipeline name unique constraint to team-scoped.

Revision ID: 064_pipeline_name_team
Revises: 063_collection_name_team
Create Date: 2026-02-09

Changes unique constraint on pipelines.name from global to team-scoped (team_id, name).
In a multi-tenant application, different teams should be able to have pipelines
with the same name (e.g., each team can have their own "Default Workflow" pipeline).
"""
import logging

from alembic import op
import sqlalchemy as sa
from sqlalchemy.exc import OperationalError, ProgrammingError

logger = logging.getLogger('alembic.runtime.migration')

revision = '064_pipeline_name_team'
down_revision = '063_collection_name_team'
branch_labels = None
depends_on = None


def upgrade() -> None:
    """
    Change pipeline name uniqueness from global to team-scoped.

    Steps:
    1. Drop the existing unique constraint on name (pipelines_name_key)
    2. Drop the unique index on name (ix_pipelines_name) if it exists
    3. Create a new composite unique constraint on (team_id, name)
    """
    bind = op.get_bind()

    if bind.dialect.name == 'postgresql':
        # Check and drop unique constraint (PostgreSQL names it 'pipelines_name_key')
        result = bind.execute(sa.text(
            "SELECT 1 FROM pg_constraint WHERE conname = 'pipelines_name_key'"
        ))
        if result.fetchone():
            op.drop_constraint('pipelines_name_key', 'pipelines', type_='unique')

        # Check and drop unique index if exists (idx_pipelines_name from __table_args__)
        result = bind.execute(sa.text(
            "SELECT 1 FROM pg_indexes WHERE indexname = 'idx_pipelines_name'"
        ))
        if result.fetchone():
            op.drop_index('idx_pipelines_name', table_name='pipelines')

        # Also check for ix_pipelines_name (auto-generated by unique=True + index=True)
        result = bind.execute(sa.text(
            "SELECT 1 FROM pg_indexes WHERE indexname = 'ix_pipelines_name'"
        ))
        if result.fetchone():
            op.drop_index('ix_pipelines_name', table_name='pipelines')

        # Check if team-scoped constraint already exists
        result = bind.execute(sa.text(
            "SELECT 1 FROM pg_constraint WHERE conname = 'uq_pipelines_team_name'"
        ))
        if not result.fetchone():
            op.create_unique_constraint(
                'uq_pipelines_team_name',
                'pipelines',
                ['team_id', 'name']
            )
    else:
        # SQLite: use try/except pattern with specific exceptions
        try:
            op.drop_constraint('pipelines_name_key', 'pipelines', type_='unique')
        except (OperationalError, ProgrammingError) as e:
            logger.warning(f"Could not drop constraint 'pipelines_name_key' (may not exist): {e}")

        try:
            op.drop_index('idx_pipelines_name', table_name='pipelines')
        except (OperationalError, ProgrammingError) as e:
            logger.warning(f"Could not drop index 'idx_pipelines_name' (may not exist): {e}")

        try:
            op.drop_index('ix_pipelines_name', table_name='pipelines')
        except (OperationalError, ProgrammingError) as e:
            logger.warning(f"Could not drop index 'ix_pipelines_name' (may not exist): {e}")

        try:
            op.create_unique_constraint(
                'uq_pipelines_team_name',
                'pipelines',
                ['team_id', 'name']
            )
        except (OperationalError, ProgrammingError) as e:
            logger.warning(f"Could not create constraint 'uq_pipelines_team_name' (may already exist): {e}")


def downgrade() -> None:
    """
    Revert to global name uniqueness.

    WARNING: This will fail if duplicate pipeline names exist across different teams.
    """
    bind = op.get_bind()

    if bind.dialect.name == 'postgresql':
        # Check and drop team-scoped constraint
        result = bind.execute(sa.text(
            "SELECT 1 FROM pg_constraint WHERE conname = 'uq_pipelines_team_name'"
        ))
        if result.fetchone():
            op.drop_constraint('uq_pipelines_team_name', 'pipelines', type_='unique')

        # Check if global index already exists
        result = bind.execute(sa.text(
            "SELECT 1 FROM pg_indexes WHERE indexname = 'idx_pipelines_name'"
        ))
        if not result.fetchone():
            op.create_index('idx_pipelines_name', 'pipelines', ['name'], unique=False)
    else:
        # SQLite: use try/except pattern with specific exceptions
        try:
            op.drop_constraint('uq_pipelines_team_name', 'pipelines', type_='unique')
        except (OperationalError, ProgrammingError) as e:
            logger.warning(f"Could not drop constraint 'uq_pipelines_team_name' (may not exist): {e}")

        try:
            op.create_index('idx_pipelines_name', 'pipelines', ['name'], unique=False)
        except (OperationalError, ProgrammingError) as e:
            logger.warning(f"Could not create index 'idx_pipelines_name' (may already exist): {e}")
