"""Change pipeline name unique constraint to team-scoped.

Revision ID: 064_pipeline_name_team
Revises: 063_collection_name_team
Create Date: 2026-02-09

Changes unique constraint on pipelines.name from global to team-scoped (team_id, name).
In a multi-tenant application, different teams should be able to have pipelines
with the same name (e.g., each team can have their own "Default Workflow" pipeline).
"""
from alembic import op
import sqlalchemy as sa


revision = '064_pipeline_name_team'
down_revision = '063_collection_name_team'
branch_labels = None
depends_on = None


def upgrade() -> None:
    """
    Change pipeline name uniqueness from global to team-scoped.

    Steps:
    1. Drop the existing unique constraint on name (pipelines_name_key)
    2. Drop the unique index on name (ix_pipelines_name) if it exists
    3. Create a new composite unique constraint on (team_id, name)
    """
    bind = op.get_bind()

    if bind.dialect.name == 'postgresql':
        # Check and drop unique constraint (PostgreSQL names it 'pipelines_name_key')
        result = bind.execute(sa.text(
            "SELECT 1 FROM pg_constraint WHERE conname = 'pipelines_name_key'"
        ))
        if result.fetchone():
            op.drop_constraint('pipelines_name_key', 'pipelines', type_='unique')

        # Check and drop unique index if exists (idx_pipelines_name from __table_args__)
        result = bind.execute(sa.text(
            "SELECT 1 FROM pg_indexes WHERE indexname = 'idx_pipelines_name'"
        ))
        if result.fetchone():
            op.drop_index('idx_pipelines_name', table_name='pipelines')

        # Also check for ix_pipelines_name (auto-generated by unique=True + index=True)
        result = bind.execute(sa.text(
            "SELECT 1 FROM pg_indexes WHERE indexname = 'ix_pipelines_name'"
        ))
        if result.fetchone():
            op.drop_index('ix_pipelines_name', table_name='pipelines')

        # Check if team-scoped constraint already exists
        result = bind.execute(sa.text(
            "SELECT 1 FROM pg_constraint WHERE conname = 'uq_pipelines_team_name'"
        ))
        if not result.fetchone():
            op.create_unique_constraint(
                'uq_pipelines_team_name',
                'pipelines',
                ['team_id', 'name']
            )
    else:
        # SQLite: use try/except pattern
        try:
            op.drop_constraint('pipelines_name_key', 'pipelines', type_='unique')
        except Exception:
            pass  # Constraint may not exist

        try:
            op.drop_index('idx_pipelines_name', table_name='pipelines')
        except Exception:
            pass  # Index may not exist

        try:
            op.drop_index('ix_pipelines_name', table_name='pipelines')
        except Exception:
            pass  # Index may not exist

        try:
            op.create_unique_constraint(
                'uq_pipelines_team_name',
                'pipelines',
                ['team_id', 'name']
            )
        except Exception:
            pass  # Constraint may already exist


def downgrade() -> None:
    """
    Revert to global name uniqueness.

    WARNING: This will fail if duplicate pipeline names exist across different teams.
    """
    op.drop_constraint('uq_pipelines_team_name', 'pipelines', type_='unique')
    op.create_index('idx_pipelines_name', 'pipelines', ['name'], unique=False)
    # Note: Not restoring unique=True to avoid potential conflicts
